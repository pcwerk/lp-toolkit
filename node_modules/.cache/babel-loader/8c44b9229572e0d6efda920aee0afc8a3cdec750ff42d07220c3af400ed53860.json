{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  INTERCEPTION_ROUTE_MARKERS: null,\n  isInterceptionRouteAppPath: null,\n  extractInterceptionRouteInformation: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  INTERCEPTION_ROUTE_MARKERS: function () {\n    return INTERCEPTION_ROUTE_MARKERS;\n  },\n  isInterceptionRouteAppPath: function () {\n    return isInterceptionRouteAppPath;\n  },\n  extractInterceptionRouteInformation: function () {\n    return extractInterceptionRouteInformation;\n  }\n});\nconst _apppaths = require(\"../../../shared/lib/router/utils/app-paths\");\nconst INTERCEPTION_ROUTE_MARKERS = [\"(..)(..)\", \"(.)\", \"(..)\", \"(...)\"];\nfunction isInterceptionRouteAppPath(path) {\n  // TODO-APP: add more serious validation\n  return path.split(\"/\").find(segment => INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m))) !== undefined;\n}\nfunction extractInterceptionRouteInformation(path) {\n  let interceptingRoute, marker, interceptedRoute;\n  for (const segment of path.split(\"/\")) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n    if (marker) {\n      [interceptingRoute, interceptedRoute] = path.split(marker, 2);\n      break;\n    }\n  }\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);\n  }\n  interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n  ;\n\n  switch (marker) {\n    case \"(.)\":\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === \"/\") {\n        interceptedRoute = `/${interceptedRoute}`;\n      } else {\n        interceptedRoute = interceptingRoute + \"/\" + interceptedRoute;\n      }\n      break;\n    case \"(..)\":\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === \"/\") {\n        throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);\n      }\n      interceptedRoute = interceptingRoute.split(\"/\").slice(0, -1).concat(interceptedRoute).join(\"/\");\n      break;\n    case \"(...)\":\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = \"/\" + interceptedRoute;\n      break;\n    case \"(..)(..)\":\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n      const splitInterceptingRoute = interceptingRoute.split(\"/\");\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);\n      }\n      interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join(\"/\");\n      break;\n    default:\n      throw new Error(\"Invariant: unexpected marker\");\n  }\n  return {\n    interceptingRoute,\n    interceptedRoute\n  };\n}","map":{"version":3,"names":["INTERCEPTION_ROUTE_MARKERS","isInterceptionRouteAppPath","extractInterceptionRouteInformation","path","split","find","segment","m","startsWith","undefined","interceptingRoute","marker","interceptedRoute","Error","_apppaths","normalizeAppPath","slice","concat","join","splitInterceptingRoute","length"],"sources":["../../../../src/server/future/helpers/interception-routes.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;EAGaA,0BAA0B,WAAAA,CAAA;WAA1BA,0BAAA;;EAOGC,0BAA0B,WAAAA,CAAA;WAA1BA,0BAAA;;EAWAC,mCAAmC,WAAAA,CAAA;WAAnCA,mCAAA;;;0BArBiB;AAG1B,MAAMF,0BAAA,GAA6B,CACxC,YACA,OACA,QACA,QACD;AAEM,SAASC,2BAA2BE,IAAY,EAAW;EAChE;EACA,OACEA,IAAA,CACGC,KAAK,CAAC,KACNC,IAAI,CAAEC,OAAA,IACLN,0BAAA,CAA2BK,IAAI,CAAEE,CAAA,IAAMD,OAAA,CAAQE,UAAU,CAACD,CAAA,QACtDE,SAAA;AAEZ;AAEO,SAASP,oCAAoCC,IAAY,EAAE;EAChE,IAAIO,iBAAA,EACFC,MAAA,EACAC,gBAAA;EAEF,KAAK,MAAMN,OAAA,IAAWH,IAAA,CAAKC,KAAK,CAAC,MAAM;IACrCO,MAAA,GAASX,0BAAA,CAA2BK,IAAI,CAAEE,CAAA,IAAMD,OAAA,CAAQE,UAAU,CAACD,CAAA;IACnE,IAAII,MAAA,EAAQ;MACT,CAACD,iBAAA,EAAmBE,gBAAA,CAAiB,GAAGT,IAAA,CAAKC,KAAK,CAACO,MAAA,EAAQ;MAC5D;IACF;EACF;EAEA,IAAI,CAACD,iBAAA,IAAqB,CAACC,MAAA,IAAU,CAACC,gBAAA,EAAkB;IACtD,MAAM,IAAIC,KAAA,CACP,+BAA8BV,IAAK,mFAAkF;EAE1H;EAEAO,iBAAA,GAAoB,IAAAI,SAAA,CAAAC,gBAAgB,EAACL,iBAAA,EAAmB;EAAA;;EAExD,QAAQC,MAAA;IACN,KAAK;MACH;MACA,IAAID,iBAAA,KAAsB,KAAK;QAC7BE,gBAAA,GAAoB,IAAGA,gBAAiB,EAAC;MAC3C,OAAO;QACLA,gBAAA,GAAmBF,iBAAA,GAAoB,MAAME,gBAAA;MAC/C;MACA;IACF,KAAK;MACH;MACA,IAAIF,iBAAA,KAAsB,KAAK;QAC7B,MAAM,IAAIG,KAAA,CACP,+BAA8BV,IAAK,8DAA6D;MAErG;MACAS,gBAAA,GAAmBF,iBAAA,CAChBN,KAAK,CAAC,KACNY,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACL,gBAAA,EACPM,IAAI,CAAC;MACR;IACF,KAAK;MACH;MACAN,gBAAA,GAAmB,MAAMA,gBAAA;MACzB;IACF,KAAK;MACH;MAEA,MAAMO,sBAAA,GAAyBT,iBAAA,CAAkBN,KAAK,CAAC;MACvD,IAAIe,sBAAA,CAAuBC,MAAM,IAAI,GAAG;QACtC,MAAM,IAAIP,KAAA,CACP,+BAA8BV,IAAK,iEAAgE;MAExG;MAEAS,gBAAA,GAAmBO,sBAAA,CAChBH,KAAK,CAAC,GAAG,CAAC,GACVC,MAAM,CAACL,gBAAA,EACPM,IAAI,CAAC;MACR;IACF;MACE,MAAM,IAAIL,KAAA,CAAM;EACpB;EAEA,OAAO;IAAEH,iBAAA;IAAmBE;EAAiB;AAC/C"},"metadata":{},"sourceType":"script","externalDependencies":[]}