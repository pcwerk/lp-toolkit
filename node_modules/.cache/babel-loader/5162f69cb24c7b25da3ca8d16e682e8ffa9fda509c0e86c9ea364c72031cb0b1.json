{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getRouteRegex: null,\n  getNamedRouteRegex: null,\n  getNamedMiddlewareRegex: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getRouteRegex: function () {\n    return getRouteRegex;\n  },\n  getNamedRouteRegex: function () {\n    return getNamedRouteRegex;\n  },\n  getNamedMiddlewareRegex: function () {\n    return getNamedMiddlewareRegex;\n  }\n});\nconst _interceptionroutes = require(\"../../../../server/future/helpers/interception-routes\");\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _removetrailingslash = require(\"./remove-trailing-slash\");\nconst NEXT_QUERY_PARAM_PREFIX = \"nxtP\";\nconst NEXT_INTERCEPTION_MARKER_PREFIX = \"nxtI\";\n/**\n * Parses a given parameter from a route to a data structure that can be used\n * to generate the parametrized route. Examples:\n *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n */\nfunction parseParameter(param) {\n  const optional = param.startsWith(\"[\") && param.endsWith(\"]\");\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n  const repeat = param.startsWith(\"...\");\n  if (repeat) {\n    param = param.slice(3);\n  }\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\nfunction getParametrizedRoute(route) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n  const groups = {};\n  let groupIndex = 1;\n  return {\n    parameterizedRoute: segments.map(segment => {\n      const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n      const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n      ;\n\n      if (markerMatch && paramMatches) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(paramMatches[1]);\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + \"([^/]+?)\";\n      } else if (paramMatches) {\n        const {\n          key,\n          repeat,\n          optional\n        } = parseParameter(paramMatches[1]);\n        groups[key] = {\n          pos: groupIndex++,\n          repeat,\n          optional\n        };\n        return repeat ? optional ? \"(?:/(.+?))?\" : \"/(.+?)\" : \"/([^/]+?)\";\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(\"\"),\n    groups\n  };\n}\nfunction getRouteRegex(normalizedRoute) {\n  const {\n    parameterizedRoute,\n    groups\n  } = getParametrizedRoute(normalizedRoute);\n  return {\n    re: new RegExp(\"^\" + parameterizedRoute + \"(?:/)?$\"),\n    groups: groups\n  };\n}\n/**\n * Builds a function to generate a minimal routeKey using only a-z and minimal\n * number of characters.\n */\nfunction buildGetSafeRouteKey() {\n  let i = 0;\n  return () => {\n    let routeKey = \"\";\n    let j = ++i;\n    while (j > 0) {\n      routeKey += String.fromCharCode(97 + (j - 1) % 26);\n      j = Math.floor((j - 1) / 26);\n    }\n    return routeKey;\n  };\n}\nfunction getSafeKeyFromSegment(param) {\n  let {\n    getSafeRouteKey,\n    segment,\n    routeKeys,\n    keyPrefix\n  } = param;\n  const {\n    key,\n    optional,\n    repeat\n  } = parseParameter(segment);\n  // replace any non-word characters since they can break\n  // the named regex\n  let cleanedKey = key.replace(/\\W/g, \"\");\n  if (keyPrefix) {\n    cleanedKey = \"\" + keyPrefix + cleanedKey;\n  }\n  let invalidKey = false;\n  // check if the key is still invalid and fallback to using a known\n  // safe key\n  if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n    invalidKey = true;\n  }\n  if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n    invalidKey = true;\n  }\n  if (invalidKey) {\n    cleanedKey = getSafeRouteKey();\n  }\n  if (keyPrefix) {\n    routeKeys[cleanedKey] = \"\" + keyPrefix + key;\n  } else {\n    routeKeys[cleanedKey] = \"\" + key;\n  }\n  return repeat ? optional ? \"(?:/(?<\" + cleanedKey + \">.+?))?\" : \"/(?<\" + cleanedKey + \">.+?)\" : \"/(?<\" + cleanedKey + \">[^/]+?)\";\n}\nfunction getNamedParametrizedRoute(route, prefixRouteKeys) {\n  const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split(\"/\");\n  const getSafeRouteKey = buildGetSafeRouteKey();\n  const routeKeys = {};\n  return {\n    namedParameterizedRoute: segments.map(segment => {\n      const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some(m => segment.startsWith(m));\n      const paramMatches = segment.match(/\\[((?:\\[.*\\])|.+)\\]/) // Check for parameters\n      ;\n\n      if (hasInterceptionMarker && paramMatches) {\n        return getSafeKeyFromSegment({\n          getSafeRouteKey,\n          segment: paramMatches[1],\n          routeKeys,\n          keyPrefix: prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n        });\n      } else if (paramMatches) {\n        return getSafeKeyFromSegment({\n          getSafeRouteKey,\n          segment: paramMatches[1],\n          routeKeys,\n          keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n        });\n      } else {\n        return \"/\" + (0, _escaperegexp.escapeStringRegexp)(segment);\n      }\n    }).join(\"\"),\n    routeKeys\n  };\n}\nfunction getNamedRouteRegex(normalizedRoute, prefixRouteKey) {\n  const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);\n  return {\n    ...getRouteRegex(normalizedRoute),\n    namedRegex: \"^\" + result.namedParameterizedRoute + \"(?:/)?$\",\n    routeKeys: result.routeKeys\n  };\n}\nfunction getNamedMiddlewareRegex(normalizedRoute, options) {\n  const {\n    parameterizedRoute\n  } = getParametrizedRoute(normalizedRoute);\n  const {\n    catchAll = true\n  } = options;\n  if (parameterizedRoute === \"/\") {\n    let catchAllRegex = catchAll ? \".*\" : \"\";\n    return {\n      namedRegex: \"^/\" + catchAllRegex + \"$\"\n    };\n  }\n  const {\n    namedParameterizedRoute\n  } = getNamedParametrizedRoute(normalizedRoute, false);\n  let catchAllGroupedRegex = catchAll ? \"(?:(/.*)?)\" : \"\";\n  return {\n    namedRegex: \"^\" + namedParameterizedRoute + catchAllGroupedRegex + \"$\"\n  };\n}","map":{"version":3,"names":["getRouteRegex","getNamedRouteRegex","getNamedMiddlewareRegex","NEXT_QUERY_PARAM_PREFIX","NEXT_INTERCEPTION_MARKER_PREFIX","parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","segments","_removetrailingslash","removeTrailingSlash","split","groups","groupIndex","parameterizedRoute","map","segment","markerMatch","_interceptionroutes","INTERCEPTION_ROUTE_MARKERS","find","m","paramMatches","match","pos","_escaperegexp","escapeStringRegexp","join","normalizedRoute","re","RegExp","buildGetSafeRouteKey","i","routeKey","j","String","fromCharCode","Math","floor","getSafeKeyFromSegment","getSafeRouteKey","routeKeys","keyPrefix","cleanedKey","replace","invalidKey","length","isNaN","parseInt","getNamedParametrizedRoute","prefixRouteKeys","namedParameterizedRoute","hasInterceptionMarker","some","undefined","prefixRouteKey","result","namedRegex","options","catchAll","catchAllRegex","catchAllGroupedRegex"],"sources":["../../../../../src/shared/lib/router/utils/route-regex.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}