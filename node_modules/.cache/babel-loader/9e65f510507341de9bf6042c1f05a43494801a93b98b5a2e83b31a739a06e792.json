{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"resolveHref\", {\n  enumerable: true,\n  get: function () {\n    return resolveHref;\n  }\n});\nconst _querystring = require(\"./querystring\");\nconst _formaturl = require(\"./format-url\");\nconst _omit = require(\"./omit\");\nconst _utils = require(\"../../utils\");\nconst _normalizetrailingslash = require(\"../../../../client/normalize-trailing-slash\");\nconst _islocalurl = require(\"./is-local-url\");\nconst _isdynamic = require(\"./is-dynamic\");\nconst _interpolateas = require(\"./interpolate-as\");\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  let base;\n  let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n  // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n  const urlParts = urlAsStringNoProto.split(\"?\");\n  if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n    console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n    const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n  }\n  // Return because it cannot be routed by the Next.js router\n  if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n  try {\n    base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL(\"/\", \"http://n\");\n  }\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n    let interpolatedAs = \"\";\n    if ((0, _isdynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n      if (result) {\n        interpolatedAs = (0, _formaturl.formatWithValidation)({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: (0, _omit.omit)(query, params)\n        });\n      }\n    }\n    // if the origin didn't change, it means we received a relative href\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}","map":{"version":3,"names":["resolveHref","router","href","resolveAs","base","urlAsString","_formaturl","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","length","urlParts","split","console","error","pathname","normalizedUrl","_utils","normalizeRepeatedSlashes","_islocalurl","isLocalURL","URL","startsWith","asPath","_","finalUrl","_normalizetrailingslash","normalizePathTrailingSlash","interpolatedAs","_isdynamic","isDynamicRoute","searchParams","query","_querystring","searchParamsToUrlQuery","result","params","_interpolateas","interpolateAs","hash","_omit","omit","resolvedHref","origin"],"sources":["../../../../../src/shared/lib/router/utils/resolve-href.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}