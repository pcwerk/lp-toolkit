"use strict";(self.webpackChunkplaywright_dev=self.webpackChunkplaywright_dev||[]).push([[225],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return m}});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),u=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=u(a),g=o,m=d["".concat(l,".").concat(g)]||d[g]||c[g]||r;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,s=new Array(r);s[0]=g;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:o,s[1]=i;for(var u=2;u<r;u++)s[u]=a[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},9247:function(e,t,a){a.d(t,{Z:function(){return d}});var n=a(7294),o=a(6010),r="tabItem_Ymn6",s=Object.defineProperty,i=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,p=(e,t,a)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a;function d({children:e,hidden:t,className:a}){return n.createElement("div",((e,t)=>{for(var a in t||(t={}))l.call(t,a)&&p(e,a,t[a]);if(i)for(var a of i(t))u.call(t,a)&&p(e,a,t[a]);return e})({role:"tabpanel",className:(0,o.Z)(r,a)},{hidden:t}),e)}},4023:function(e,t,a){a.d(t,{Z:function(){return Z}});var n=a(7294),o=a(6010),r=a(7287),s=a(6550),i=a(3962),l=a(9920),u=a(5801),p=Object.defineProperty,d=Object.defineProperties,c=Object.getOwnPropertyDescriptors,g=Object.getOwnPropertySymbols,m=Object.prototype.hasOwnProperty,f=Object.prototype.propertyIsEnumerable,h=(e,t,a)=>t in e?p(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a;function w(e){return function(e){var t,a;return null!=(a=null==(t=n.Children.map(e,(e=>{if(!e||(0,n.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})))?void 0:t.filter(Boolean))?a:[]}(e).map((({props:{value:e,label:t,attributes:a,default:n}})=>({value:e,label:t,attributes:a,default:n})))}function k(e){const{values:t,children:a}=e;return(0,n.useMemo)((()=>{const e=null!=t?t:w(a);return function(e){const t=(0,l.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function y({value:e,tabValues:t}){return t.some((t=>t.value===e))}function x({queryString:e=!1,groupId:t}){const a=(0,s.k6)(),o=function({queryString:e=!1,groupId:t}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:e,groupId:t});return[(0,i._X)(o),(0,n.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);var n,r;t.set(o,e),a.replace((n=((e,t)=>{for(var a in t||(t={}))m.call(t,a)&&h(e,a,t[a]);if(g)for(var a of g(t))f.call(t,a)&&h(e,a,t[a]);return e})({},a.location),r={search:t.toString()},d(n,c(r))))}),[o,a])]}function b(e){const{defaultValue:t,queryString:a=!1,groupId:o}=e,r=k(e),[s,i]=(0,n.useState)((()=>function({defaultValue:e,tabValues:t}){var a;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!y({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const n=null!=(a=t.find((e=>e.default)))?a:t[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:r}))),[l,p]=x({queryString:a,groupId:o}),[d,c]=function({groupId:e}){const t=function(e){return e?`docusaurus.tab.${e}`:null}(e),[a,o]=(0,u.Nk)(t);return[a,(0,n.useCallback)((e=>{t&&o.set(e)}),[t,o])]}({groupId:o}),g=(()=>{const e=null!=l?l:d;return y({value:e,tabValues:r})?e:null})();(0,n.useLayoutEffect)((()=>{g&&i(g)}),[g]);return{selectedValue:s,selectValue:(0,n.useCallback)((e=>{if(!y({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);i(e),p(e),c(e)}),[p,c,r]),tabValues:r}}var v=a(5710),N="tabList__CuJ",T="tabItem_LNqP",P=Object.defineProperty,I=Object.defineProperties,j=Object.getOwnPropertyDescriptors,C=Object.getOwnPropertySymbols,F=Object.prototype.hasOwnProperty,B=Object.prototype.propertyIsEnumerable,S=(e,t,a)=>t in e?P(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,O=(e,t)=>{for(var a in t||(t={}))F.call(t,a)&&S(e,a,t[a]);if(C)for(var a of C(t))B.call(t,a)&&S(e,a,t[a]);return e};function D({className:e,block:t,selectedValue:a,selectValue:s,tabValues:i}){const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,r.o5)(),p=e=>{const t=e.currentTarget,n=l.indexOf(t),o=i[n].value;o!==a&&(u(t),s(o))},d=e=>{var t,a;let n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const a=l.indexOf(e.currentTarget)+1;n=null!=(t=l[a])?t:l[0];break}case"ArrowLeft":{const t=l.indexOf(e.currentTarget)-1;n=null!=(a=l[t])?a:l[l.length-1];break}}null==n||n.focus()};return n.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},e)},i.map((({value:e,label:t,attributes:r})=>{return n.createElement("li",(s=O({role:"tab",tabIndex:a===e?0:-1,"aria-selected":a===e,key:e,ref:e=>l.push(e),onKeyDown:d,onClick:p},r),i={className:(0,o.Z)("tabs__item",T,null==r?void 0:r.className,{"tabs__item--active":a===e})},I(s,j(i))),null!=t?t:e);var s,i})))}function E({lazy:e,children:t,selectedValue:a}){const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const e=o.find((e=>e.props.value===a));return e?(0,n.cloneElement)(e,{className:"margin-top--md"}):null}return n.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,n.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function L(e){const t=b(e);return n.createElement("div",{className:(0,o.Z)("tabs-container",N)},n.createElement(D,O(O({},e),t)),n.createElement(E,O(O({},e),t)))}function Z(e){const t=(0,v.Z)();return n.createElement(L,O({key:String(t)},e))}},5478:function(e,t,a){a.r(t),a.d(t,{assets:function(){return w},contentTitle:function(){return f},default:function(){return x},frontMatter:function(){return m},metadata:function(){return h},toc:function(){return k}});var n=a(3905),o=a(4023),r=a(9247),s=Object.defineProperty,i=Object.defineProperties,l=Object.getOwnPropertyDescriptors,u=Object.getOwnPropertySymbols,p=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,c=(e,t,a)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,g=(e,t)=>{for(var a in t||(t={}))p.call(t,a)&&c(e,a,t[a]);if(u)for(var a of u(t))d.call(t,a)&&c(e,a,t[a]);return e};const m={id:"test-fixtures",title:"Fixtures"},f=void 0,h={unversionedId:"test-fixtures",id:"version-stable/test-fixtures",title:"Fixtures",description:"Introduction",source:"@site/versioned_docs/version-stable/test-fixtures.mdx",sourceDirName:".",slug:"/test-fixtures",permalink:"/docs/test-fixtures",draft:!1,tags:[],version:"stable",frontMatter:{id:"test-fixtures",title:"Fixtures"},sidebar:"docs",previous:{title:"Emulation",permalink:"/docs/emulation"},next:{title:"Global setup and teardown",permalink:"/docs/test-global-setup-teardown"}},w={},k=[{value:"Introduction",id:"introduction",level:2},{value:"Built-in fixtures",id:"built-in-fixtures",level:3},{value:"Without fixtures",id:"without-fixtures",level:3},{value:"With fixtures",id:"with-fixtures",level:3},{value:"Creating a fixture",id:"creating-a-fixture",level:2},{value:"Using a fixture",id:"using-a-fixture",level:2},{value:"Overriding fixtures",id:"overriding-fixtures",level:2},{value:"Worker-scoped fixtures",id:"worker-scoped-fixtures",level:2},{value:"Automatic fixtures",id:"automatic-fixtures",level:2},{value:"Fixture timeout",id:"fixture-timeout",level:2},{value:"Fixtures-options",id:"fixtures-options",level:2},{value:"Execution order",id:"execution-order",level:2}],y={toc:k};function x(e){var t,a=e,{components:s}=a,c=((e,t)=>{var a={};for(var n in e)p.call(e,n)&&t.indexOf(n)<0&&(a[n]=e[n]);if(null!=e&&u)for(var n of u(e))t.indexOf(n)<0&&d.call(e,n)&&(a[n]=e[n]);return a})(a,["components"]);return(0,n.kt)("wrapper",(t=g(g({},y),c),i(t,l({components:s,mdxType:"MDXLayout"}))),(0,n.kt)("h2",g({},{id:"introduction"}),"Introduction"),(0,n.kt)("p",null,"Playwright Test is based on the concept of test fixtures. Test fixtures are used to establish environment for each test, giving the test everything it needs and nothing else. Test fixtures are isolated between tests. With fixtures, you can group tests based on their meaning, instead of their common setup."),(0,n.kt)("h3",g({},{id:"built-in-fixtures"}),"Built-in fixtures"),(0,n.kt)("p",null,"You have already used test fixtures in your first test."),(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"import { test, expect } from '@playwright/test';\n\ntest('basic test', async ({ page }) => {\n  await page.goto('https://playwright.dev/');\n\n  await expect(page).toHaveTitle(/Playwright/);\n});\n")),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"{ page }")," argument tells Playwright Test to setup the ",(0,n.kt)("inlineCode",{parentName:"p"},"page")," fixture and provide it to your test function."),(0,n.kt)("p",null,"Here is a list of the pre-defined fixtures that you are likely to use most of the time:"),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",g({parentName:"tr"},{align:"left"}),"Fixture"),(0,n.kt)("th",g({parentName:"tr"},{align:"left"}),"Type"),(0,n.kt)("th",g({parentName:"tr"},{align:"left"}),"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"page"),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),(0,n.kt)("a",g({parentName:"td"},{href:"/docs/api/class-page",title:"Page"}),"Page")),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"Isolated page for this test run.")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"context"),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),(0,n.kt)("a",g({parentName:"td"},{href:"/docs/api/class-browsercontext",title:"BrowserContext"}),"BrowserContext")),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"Isolated context for this test run. The ",(0,n.kt)("inlineCode",{parentName:"td"},"page")," fixture belongs to this context as well. Learn how to ",(0,n.kt)("a",g({parentName:"td"},{href:"/docs/test-configuration"}),"configure context"),".")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"browser"),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),(0,n.kt)("a",g({parentName:"td"},{href:"/docs/api/class-browser",title:"Browser"}),"Browser")),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"Browsers are shared across tests to optimize resources. Learn how to ",(0,n.kt)("a",g({parentName:"td"},{href:"/docs/test-configuration"}),"configure browser"),".")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"browserName"),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),(0,n.kt)("a",g({parentName:"td"},{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type",title:"string"}),"string")),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"The name of the browser currently running the test. Either ",(0,n.kt)("inlineCode",{parentName:"td"},"chromium"),", ",(0,n.kt)("inlineCode",{parentName:"td"},"firefox")," or ",(0,n.kt)("inlineCode",{parentName:"td"},"webkit"),".")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"request"),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),(0,n.kt)("a",g({parentName:"td"},{href:"/docs/api/class-apirequestcontext",title:"APIRequestContext"}),"APIRequestContext")),(0,n.kt)("td",g({parentName:"tr"},{align:"left"}),"Isolated ",(0,n.kt)("a",g({parentName:"td"},{href:"/docs/api/class-apirequestcontext"}),"APIRequestContext")," instance for this test run.")))),(0,n.kt)("h3",g({},{id:"without-fixtures"}),"Without fixtures"),(0,n.kt)("p",null,"Here is how typical test environment setup differs between traditional test style and the fixture-based one."),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"TodoPage"),' is a class that helps interacting with a "todo list" page of the web app, following the ',(0,n.kt)("a",g({parentName:"p"},{href:"/docs/pom"}),"Page Object Model")," pattern. It uses Playwright's ",(0,n.kt)("inlineCode",{parentName:"p"},"page")," internally."),(0,n.kt)("details",null,(0,n.kt)("summary",null,"Click to expand the code for the ",(0,n.kt)("code",null,"TodoPage")),(0,n.kt)("div",null,(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo-page.ts"',title:'"todo-page.ts"'}),"import type { Page, Locator } from '@playwright/test';\n\nexport class TodoPage {\n  private readonly inputBox: Locator;\n  private readonly todoItems: Locator;\n\n  constructor(public readonly page: Page) {\n    this.inputBox = this.page.locator('input.new-todo');\n    this.todoItems = this.page.getByTestId('todo-item');\n  }\n\n  async goto() {\n    await this.page.goto('https://demo.playwright.dev/todomvc/');\n  }\n\n  async addToDo(text: string) {\n    await this.inputBox.fill(text);\n    await this.inputBox.press('Enter');\n  }\n\n  async remove(text: string) {\n    const todo = this.todoItems.filter({ hasText: text });\n    await todo.hover();\n    await todo.getByLabel('Delete').click();\n  }\n\n  async removeAll() {\n    while ((await this.todoItems.count()) > 0) {\n      await this.todoItems.first().hover();\n      await this.todoItems.getByLabel('Delete').first().click();\n    }\n  }\n}\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo-page.js"',title:'"todo-page.js"'}),"export class TodoPage {\n  /**\n   * @param {import('@playwright/test').Page} page\n   */\n  constructor(page) {\n    this.page = page;\n    this.inputBox = this.page.locator('input.new-todo');\n    this.todoItems = this.page.getByTestId('todo-item');\n  }\n\n  async goto() {\n    await this.page.goto('https://demo.playwright.dev/todomvc/');\n  }\n\n  /**\n   * @param {string} text\n   */\n  async addToDo(text) {\n    await this.inputBox.fill(text);\n    await this.inputBox.press('Enter');\n  }\n\n  /**\n   * @param {string} text\n   */\n  async remove(text) {\n    const todo = this.todoItems.filter({ hasText: text });\n    await todo.hover();\n    await todo.getByLabel('Delete').click();\n  }\n\n  async removeAll() {\n    while ((await this.todoItems.count()) > 0) {\n      await this.todoItems.first().hover();\n      await this.todoItems.getByLabel('Delete').first().click();\n    }\n  }\n}\n")))))),(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo.spec.ts"',title:'"todo.spec.ts"'}),"const { test } = require('@playwright/test');\nconst { TodoPage } = require('./todo-page');\n\ntest.describe('todo tests', () => {\n  let todoPage;\n\n  test.beforeEach(async ({ page }) => {\n    todoPage = new TodoPage(page);\n    await todoPage.goto();\n    await todoPage.addToDo('item1');\n    await todoPage.addToDo('item2');\n  });\n\n  test.afterEach(async () => {\n    await todoPage.removeAll();\n  });\n\n  test('should add an item', async () => {\n    await todoPage.addToDo('my item');\n    // ...\n  });\n\n  test('should remove an item', async () => {\n    await todoPage.remove('item1');\n    // ...\n  });\n});\n")),(0,n.kt)("h3",g({},{id:"with-fixtures"}),"With fixtures"),(0,n.kt)("p",null,"Fixtures have a number of advantages over before/after hooks:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Fixtures ",(0,n.kt)("strong",{parentName:"li"},"encapsulate")," setup and teardown in the same place so it is easier to write."),(0,n.kt)("li",{parentName:"ul"},"Fixtures are ",(0,n.kt)("strong",{parentName:"li"},"reusable")," between test files - you can define them once and use in all your tests. That's how Playwright's built-in ",(0,n.kt)("inlineCode",{parentName:"li"},"page")," fixture works."),(0,n.kt)("li",{parentName:"ul"},"Fixtures are ",(0,n.kt)("strong",{parentName:"li"},"on-demand")," - you can define as many fixtures as you'd like, and Playwright Test will setup only the ones needed by your test and nothing else."),(0,n.kt)("li",{parentName:"ul"},"Fixtures are ",(0,n.kt)("strong",{parentName:"li"},"composable")," - they can depend on each other to provide complex behaviors."),(0,n.kt)("li",{parentName:"ul"},"Fixtures are ",(0,n.kt)("strong",{parentName:"li"},"flexible"),". Tests can use any combinations of the fixtures to tailor precise environment they need, without affecting other tests."),(0,n.kt)("li",{parentName:"ul"},"Fixtures simplify ",(0,n.kt)("strong",{parentName:"li"},"grouping"),". You no longer need to wrap tests in ",(0,n.kt)("inlineCode",{parentName:"li"},"describe"),"s that set up environment, and are free to group your tests by their meaning instead.")),(0,n.kt)("details",null,(0,n.kt)("summary",null,"Click to expand the code for the ",(0,n.kt)("code",null,"TodoPage")),(0,n.kt)("div",null,(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo-page.ts"',title:'"todo-page.ts"'}),"import type { Page, Locator } from '@playwright/test';\n\nexport class TodoPage {\n  private readonly inputBox: Locator;\n  private readonly todoItems: Locator;\n\n  constructor(public readonly page: Page) {\n    this.inputBox = this.page.locator('input.new-todo');\n    this.todoItems = this.page.getByTestId('todo-item');\n  }\n\n  async goto() {\n    await this.page.goto('https://demo.playwright.dev/todomvc/');\n  }\n\n  async addToDo(text: string) {\n    await this.inputBox.fill(text);\n    await this.inputBox.press('Enter');\n  }\n\n  async remove(text: string) {\n    const todo = this.todoItems.filter({ hasText: text });\n    await todo.hover();\n    await todo.getByLabel('Delete').click();\n  }\n\n  async removeAll() {\n    while ((await this.todoItems.count()) > 0) {\n      await this.todoItems.first().hover();\n      await this.todoItems.getByLabel('Delete').first().click();\n    }\n  }\n}\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo-page.js"',title:'"todo-page.js"'}),"export class TodoPage {\n  /**\n   * @param {import('@playwright/test').Page} page\n   */\n  constructor(page) {\n    this.page = page;\n    this.inputBox = this.page.locator('input.new-todo');\n    this.todoItems = this.page.getByTestId('todo-item');\n  }\n\n  async goto() {\n    await this.page.goto('https://demo.playwright.dev/todomvc/');\n  }\n\n  /**\n   * @param {string} text\n   */\n  async addToDo(text) {\n    await this.inputBox.fill(text);\n    await this.inputBox.press('Enter');\n  }\n\n  /**\n   * @param {string} text\n   */\n  async remove(text) {\n    const todo = this.todoItems.filter({ hasText: text });\n    await todo.hover();\n    await todo.getByLabel('Delete').click();\n  }\n\n  async removeAll() {\n    while ((await this.todoItems.count()) > 0) {\n      await this.todoItems.first().hover();\n      await this.todoItems.getByLabel('Delete').first().click();\n    }\n  }\n}\n")))))),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="example.spec.ts"',title:'"example.spec.ts"'}),"import { test as base } from '@playwright/test';\nimport { TodoPage } from './todo-page';\n\n// Extend basic test by providing a \"todoPage\" fixture.\nconst test = base.extend<{ todoPage: TodoPage }>({\n  todoPage: async ({ page }, use) => {\n    const todoPage = new TodoPage(page);\n    await todoPage.goto();\n    await todoPage.addToDo('item1');\n    await todoPage.addToDo('item2');\n    await use(todoPage);\n    await todoPage.removeAll();\n  },\n});\n\ntest('should add an item', async ({ todoPage }) => {\n  await todoPage.addToDo('my item');\n  // ...\n});\n\ntest('should remove an item', async ({ todoPage }) => {\n  await todoPage.remove('item1');\n  // ...\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo.spec.js"',title:'"todo.spec.js"'}),"const base = require('@playwright/test');\nconst { TodoPage } = require('./todo-page');\n\n// Extend basic test by providing a \"todoPage\" fixture.\nconst test = base.test.extend({\n  todoPage: async ({ page }, use) => {\n    const todoPage = new TodoPage(page);\n    await todoPage.goto();\n    await todoPage.addToDo('item1');\n    await todoPage.addToDo('item2');\n    await use(todoPage);\n    await todoPage.removeAll();\n  },\n});\n\ntest('should add an item', async ({ todoPage }) => {\n  await todoPage.addToDo('my item');\n  // ...\n});\n\ntest('should remove an item', async ({ todoPage }) => {\n  await todoPage.remove('item1');\n  // ...\n});\n")))),(0,n.kt)("h2",g({},{id:"creating-a-fixture"}),"Creating a fixture"),(0,n.kt)("p",null,"To create your own fixture, use ",(0,n.kt)("a",g({parentName:"p"},{href:"/docs/api/class-test#test-extend"}),"test.extend()")," to create a new ",(0,n.kt)("inlineCode",{parentName:"p"},"test")," object that will include it."),(0,n.kt)("p",null,"Below we create two fixtures ",(0,n.kt)("inlineCode",{parentName:"p"},"todoPage")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"settingsPage")," that follow the ",(0,n.kt)("a",g({parentName:"p"},{href:"/docs/pom"}),"Page Object Model")," pattern."),(0,n.kt)("details",null,(0,n.kt)("summary",null,"Click to expand the code for the ",(0,n.kt)("code",null,"TodoPage")," and ",(0,n.kt)("code",null,"SettingsPage")),(0,n.kt)("div",null,(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo-page.ts"',title:'"todo-page.ts"'}),"import type { Page, Locator } from '@playwright/test';\n\nexport class TodoPage {\n  private readonly inputBox: Locator;\n  private readonly todoItems: Locator;\n\n  constructor(public readonly page: Page) {\n    this.inputBox = this.page.locator('input.new-todo');\n    this.todoItems = this.page.getByTestId('todo-item');\n  }\n\n  async goto() {\n    await this.page.goto('https://demo.playwright.dev/todomvc/');\n  }\n\n  async addToDo(text: string) {\n    await this.inputBox.fill(text);\n    await this.inputBox.press('Enter');\n  }\n\n  async remove(text: string) {\n    const todo = this.todoItems.filter({ hasText: text });\n    await todo.hover();\n    await todo.getByLabel('Delete').click();\n  }\n\n  async removeAll() {\n    while ((await this.todoItems.count()) > 0) {\n      await this.todoItems.first().hover();\n      await this.todoItems.getByLabel('Delete').first().click();\n    }\n  }\n}\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo-page.js"',title:'"todo-page.js"'}),"export class TodoPage {\n  /**\n   * @param {import('@playwright/test').Page} page\n   */\n  constructor(page) {\n    this.page = page;\n    this.inputBox = this.page.locator('input.new-todo');\n    this.todoItems = this.page.getByTestId('todo-item');\n  }\n\n  async goto() {\n    await this.page.goto('https://demo.playwright.dev/todomvc/');\n  }\n\n  /**\n   * @param {string} text\n   */\n  async addToDo(text) {\n    await this.inputBox.fill(text);\n    await this.inputBox.press('Enter');\n  }\n\n  /**\n   * @param {string} text\n   */\n  async remove(text) {\n    const todo = this.todoItems.filter({ hasText: text });\n    await todo.hover();\n    await todo.getByLabel('Delete').click();\n  }\n\n  async removeAll() {\n    while ((await this.todoItems.count()) > 0) {\n      await this.todoItems.first().hover();\n      await this.todoItems.getByLabel('Delete').first().click();\n    }\n  }\n}\n")))),(0,n.kt)("p",null,"SettingsPage is similar:"),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="settings-page.ts"',title:'"settings-page.ts"'}),"import type { Page } from '@playwright/test';\n\nexport class SettingsPage {\n  constructor(public readonly page: Page) {\n  }\n\n  async switchToDarkMode() {\n    // ...\n  }\n}\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="settings-page.js"',title:'"settings-page.js"'}),"export class SettingsPage {\n  /**\n   * @param {import('@playwright/test').Page} page\n   */\n  constructor(page) {\n    this.page = page;\n  }\n\n  async switchToDarkMode() {\n    // ...\n  }\n}\n")))))),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="my-test.ts"',title:'"my-test.ts"'}),"import { test as base } from '@playwright/test';\nimport { TodoPage } from './todo-page';\nimport { SettingsPage } from './settings-page';\n\n// Declare the types of your fixtures.\ntype MyFixtures = {\n  todoPage: TodoPage;\n  settingsPage: SettingsPage;\n};\n\n// Extend base test by providing \"todoPage\" and \"settingsPage\".\n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.\nexport const test = base.extend<MyFixtures>({\n  todoPage: async ({ page }, use) => {\n    // Set up the fixture.\n    const todoPage = new TodoPage(page);\n    await todoPage.goto();\n    await todoPage.addToDo('item1');\n    await todoPage.addToDo('item2');\n\n    // Use the fixture value in the test.\n    await use(todoPage);\n\n    // Clean up the fixture.\n    await todoPage.removeAll();\n  },\n\n  settingsPage: async ({ page }, use) => {\n    await use(new SettingsPage(page));\n  },\n});\nexport { expect } from '@playwright/test';\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="my-test.js"',title:'"my-test.js"'}),"const base = require('@playwright/test');\nconst { TodoPage } = require('./todo-page');\nconst { SettingsPage } = require('./settings-page');\n\n// Extend base test by providing \"todoPage\" and \"settingsPage\".\n// This new \"test\" can be used in multiple test files, and each of them will get the fixtures.\nexports.test = base.test.extend({\n  todoPage: async ({ page }, use) => {\n    // Set up the fixture.\n    const todoPage = new TodoPage(page);\n    await todoPage.goto();\n    await todoPage.addToDo('item1');\n    await todoPage.addToDo('item2');\n\n    // Use the fixture value in the test.\n    await use(todoPage);\n\n    // Clean up the fixture.\n    await todoPage.removeAll();\n  },\n\n  settingsPage: async ({ page }, use) => {\n    await use(new SettingsPage(page));\n  },\n});\nexports.expect = base.expect;\n")))),(0,n.kt)("admonition",g({},{type:"note"}),(0,n.kt)("p",{parentName:"admonition"},"Custom fixture names should start with a letter or underscore, and can contain only letters, numbers, underscores.")),(0,n.kt)("h2",g({},{id:"using-a-fixture"}),"Using a fixture"),(0,n.kt)("p",null,"Just mention fixture in your test function argument, and test runner will take care of it. Fixtures are also available in hooks and other fixtures. If you use TypeScript, fixtures will have the right type."),(0,n.kt)("p",null,"Below we use the ",(0,n.kt)("inlineCode",{parentName:"p"},"todoPage")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"settingsPage")," fixtures defined above."),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"import { test, expect } from './my-test';\n\ntest.beforeEach(async ({ settingsPage }) => {\n  await settingsPage.switchToDarkMode();\n});\n\ntest('basic test', async ({ todoPage, page }) => {\n  await todoPage.addToDo('something nice');\n  await expect(page.getByTestId('todo-title')).toContainText(['something nice']);\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"const { test, expect } = require('./my-test');\n\ntest.beforeEach(async ({ settingsPage }) => {\n  await settingsPage.switchToDarkMode();\n});\n\ntest('basic test', async ({ todoPage, page }) => {\n  await todoPage.addToDo('something nice');\n  await expect(page.getByTestId('todo-title')).toContainText(['something nice']);\n});\n")))),(0,n.kt)("h2",g({},{id:"overriding-fixtures"}),"Overriding fixtures"),(0,n.kt)("p",null,"In addition to creating your own fixtures, you can also override existing fixtures to fit your needs. Consider the following example which overrides the ",(0,n.kt)("inlineCode",{parentName:"p"},"page")," fixture by automatically navigating to some ",(0,n.kt)("inlineCode",{parentName:"p"},"baseURL"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"import { test as base } from '@playwright/test';\n\nexport const test = base.extend({\n  page: async ({ baseURL, page }, use) => {\n    await page.goto(baseURL);\n    await use(page);\n  },\n});\n")),(0,n.kt)("p",null,"Notice that in this example, the ",(0,n.kt)("inlineCode",{parentName:"p"},"page")," fixture is able to depend on other built-in fixtures such as ",(0,n.kt)("a",g({parentName:"p"},{href:"/docs/api/class-testoptions#test-options-base-url"}),"testOptions.baseURL"),". We can now configure ",(0,n.kt)("inlineCode",{parentName:"p"},"baseURL")," in the configuration file, or locally in the test file with ",(0,n.kt)("a",g({parentName:"p"},{href:"/docs/api/class-test#test-use"}),"test.use()"),"."),(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="example.spec.ts"',title:'"example.spec.ts"'}),"\ntest.use({ baseURL: 'https://playwright.dev' });\n")),(0,n.kt)("p",null,"Fixtures can also be overridden where the base fixture is completely replaced with something different. For example, we could override the ",(0,n.kt)("a",g({parentName:"p"},{href:"/docs/api/class-testoptions#test-options-storage-state"}),"testOptions.storageState")," fixture to provide our own data."),(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"import { test as base } from '@playwright/test';\n\nexport const test = base.extend({\n  storageState: async ({}, use) => {\n    const cookie = await getAuthCookie();\n    await use({ cookies: [cookie] });\n  },\n});\n")),(0,n.kt)("h2",g({},{id:"worker-scoped-fixtures"}),"Worker-scoped fixtures"),(0,n.kt)("p",null,"Playwright Test uses ",(0,n.kt)("a",g({parentName:"p"},{href:"/docs/test-parallel"}),"worker processes")," to run test files. Similarly to how test fixtures are set up for individual test runs, worker fixtures are set up for each worker process. That's where you can set up services, run servers, etc. Playwright Test will reuse the worker process for as many test files as it can, provided their worker fixtures match and hence environments are identical."),(0,n.kt)("p",null,"Below we'll create an ",(0,n.kt)("inlineCode",{parentName:"p"},"account")," fixture that will be shared by all tests in the same worker, and override the ",(0,n.kt)("inlineCode",{parentName:"p"},"page")," fixture to login into this account for each test. To generate unique accounts, we'll use the ",(0,n.kt)("a",g({parentName:"p"},{href:"/docs/api/class-workerinfo#worker-info-worker-index"}),"workerInfo.workerIndex")," that is available to any test or fixture. Note the tuple-like syntax for the worker fixture - we have to pass ",(0,n.kt)("inlineCode",{parentName:"p"},"{scope: 'worker'}")," so that test runner sets up this fixture once per worker."),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="my-test.ts"',title:'"my-test.ts"'}),"import { test as base } from '@playwright/test';\n\ntype Account = {\n  username: string;\n  password: string;\n};\n\n// Note that we pass worker fixture types as a second template parameter.\nexport const test = base.extend<{}, { account: Account }>({\n  account: [async ({ browser }, use, workerInfo) => {\n    // Unique username.\n    const username = 'user' + workerInfo.workerIndex;\n    const password = 'verysecure';\n\n    // Create the account with Playwright.\n    const page = await browser.newPage();\n    await page.goto('/signup');\n    await page.getByLabel('User Name').fill(username);\n    await page.getByLabel('Password').fill(password);\n    await page.getByText('Sign up').click();\n    // Make sure everything is ok.\n    await expect(page.getByTestId('result')).toHaveText('Success');\n    // Do not forget to cleanup.\n    await page.close();\n\n    // Use the account value.\n    await use({ username, password });\n  }, { scope: 'worker' }],\n\n  page: async ({ page, account }, use) => {\n    // Sign in with our account.\n    const { username, password } = account;\n    await page.goto('/signin');\n    await page.getByLabel('User Name').fill(username);\n    await page.getByLabel('Password').fill(password);\n    await page.getByText('Sign in').click();\n    await expect(page.getByTestId('userinfo')).toHaveText(username);\n\n    // Use signed-in page in the test.\n    await use(page);\n  },\n});\nexport { expect } from '@playwright/test';\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="my-test.js"',title:'"my-test.js"'}),"const base = require('@playwright/test');\n\nexports.test = base.test.extend({\n  account: [async ({ browser }, use, workerInfo) => {\n    // Unique username.\n    const username = 'user' + workerInfo.workerIndex;\n    const password = 'verysecure';\n\n    // Create the account with Playwright.\n    const page = await browser.newPage();\n    await page.goto('/signup');\n    await page.getByLabel('User Name').fill(username);\n    await page.getByLabel('Password').fill(password);\n    await page.getByText('Sign up').click();\n    // Make sure everything is ok.\n    await expect(page.locator('#result')).toHaveText('Success');\n    // Do not forget to cleanup.\n    await page.close();\n\n    // Use the account value.\n    await use({ username, password });\n  }, { scope: 'worker' }],\n\n  page: async ({ page, account }, use) => {\n    // Sign in with our account.\n    const { username, password } = account;\n    await page.goto('/signin');\n    await page.getByLabel('User Name').fill(username);\n    await page.getByLabel('Password').fill(password);\n    await page.getByText('Sign in').click();\n    await expect(page.getByTestId('userinfo')).toHaveText(username);\n\n    // Use signed-in page in the test.\n    await use(page);\n  },\n});\nexports.expect = base.expect;\n")))),(0,n.kt)("h2",g({},{id:"automatic-fixtures"}),"Automatic fixtures"),(0,n.kt)("p",null,"Automatic fixtures are set up for each test/worker, even when the test does not list them directly. To create an automatic fixture, use the tuple syntax and pass ",(0,n.kt)("inlineCode",{parentName:"p"},"{ auto: true }"),"."),(0,n.kt)("p",null,"Here is an example fixture that automatically attaches debug logs when the test fails, so we can later review the logs in the reporter. Note how it uses ",(0,n.kt)("a",g({parentName:"p"},{href:"/docs/api/class-testinfo",title:"TestInfo"}),"TestInfo")," object that is available in each test/fixture to retrieve metadata about the test being run."),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="my-test.ts"',title:'"my-test.ts"'}),"import * as debug from 'debug';\nimport * as fs from 'fs';\nimport { test as base } from '@playwright/test';\n\nexport const test = base.extend<{ saveLogs: void }>({\n  saveLogs: [async ({}, use, testInfo) => {\n    // Collecting logs during the test.\n    const logs = [];\n    debug.log = (...args) => logs.push(args.map(String).join(''));\n    debug.enable('myserver');\n\n    await use();\n\n    // After the test we can check whether the test passed or failed.\n    if (testInfo.status !== testInfo.expectedStatus) {\n      // outputPath() API guarantees a unique file name.\n      const logFile = testInfo.outputPath('logs.txt');\n      await fs.promises.writeFile(logFile, logs.join('\\n'), 'utf8');\n      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });\n    }\n  }, { auto: true }],\n});\nexport { expect } from '@playwright/test';\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="my-test.js"',title:'"my-test.js"'}),"const debug = require('debug');\nconst fs = require('fs');\nconst base = require('@playwright/test');\n\nexports.test = base.test.extend({\n  saveLogs: [async ({}, use, testInfo) => {\n    // Collecting logs during the test.\n    const logs = [];\n    debug.log = (...args) => logs.push(args.map(String).join(''));\n    debug.enable('myserver');\n\n    await use();\n\n    // After the test we can check whether the test passed or failed.\n    if (testInfo.status !== testInfo.expectedStatus) {\n      // outputPath() API guarantees a unique file name.\n      const logFile = testInfo.outputPath('logs.txt');\n      await fs.promises.writeFile(logFile, logs.join('\\n'), 'utf8');\n      testInfo.attachments.push({ name: 'logs', contentType: 'text/plain', path: logFile });\n    }\n  }, { auto: true }],\n});\n")))),(0,n.kt)("h2",g({},{id:"fixture-timeout"}),"Fixture timeout"),(0,n.kt)("p",null,"By default, fixture shares timeout with the test. However, for slow fixtures, especially ",(0,n.kt)("a",g({parentName:"p"},{href:"#worker-scoped-fixtures"}),"worker-scoped")," ones, it is convenient to have a separate timeout. This way you can keep the overall test timeout small, and give the slow fixture more time."),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"import { test as base, expect } from '@playwright/test';\n\nconst test = base.extend<{ slowFixture: string }>({\n  slowFixture: [async ({}, use) => {\n    // ... perform a slow operation ...\n    await use('hello');\n  }, { timeout: 60000 }]\n});\n\ntest('example test', async ({ slowFixture }) => {\n  // ...\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"const { test: base, expect } = require('@playwright/test');\n\nconst test = base.extend({\n  slowFixture: [async ({}, use) => {\n    // ... perform a slow operation ...\n    await use('hello');\n  }, { timeout: 60000 }]\n});\n\ntest('example test', async ({ slowFixture }) => {\n  // ...\n});\n")))),(0,n.kt)("h2",g({},{id:"fixtures-options"}),"Fixtures-options"),(0,n.kt)("admonition",g({},{type:"note"}),(0,n.kt)("p",{parentName:"admonition"},"Overriding custom fixtures in the config file has changed in version 1.18. ",(0,n.kt)("a",g({parentName:"p"},{href:"./release-notes#breaking-change-custom-config-options"}),"Learn more"),".")),(0,n.kt)("p",null,'Playwright Test supports running multiple test projects that can be separately configured. You can use "option" fixtures to make your configuration options declarative and type-checked. Learn more about ',(0,n.kt)("a",g({parentName:"p"},{href:"/docs/test-parameterize"}),"parametrizing tests"),"."),(0,n.kt)("p",null,"Below we'll create a ",(0,n.kt)("inlineCode",{parentName:"p"},"defaultItem")," option in addition to the ",(0,n.kt)("inlineCode",{parentName:"p"},"todoPage")," fixture from other examples. This option will be set in configuration file. Note the tuple syntax and ",(0,n.kt)("inlineCode",{parentName:"p"},"{ option: true }")," argument."),(0,n.kt)("details",null,(0,n.kt)("summary",null,"Click to expand the code for the ",(0,n.kt)("code",null,"TodoPage")),(0,n.kt)("div",null,(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo-page.ts"',title:'"todo-page.ts"'}),"import type { Page, Locator } from '@playwright/test';\n\nexport class TodoPage {\n  private readonly inputBox: Locator;\n  private readonly todoItems: Locator;\n\n  constructor(public readonly page: Page) {\n    this.inputBox = this.page.locator('input.new-todo');\n    this.todoItems = this.page.getByTestId('todo-item');\n  }\n\n  async goto() {\n    await this.page.goto('https://demo.playwright.dev/todomvc/');\n  }\n\n  async addToDo(text: string) {\n    await this.inputBox.fill(text);\n    await this.inputBox.press('Enter');\n  }\n\n  async remove(text: string) {\n    const todo = this.todoItems.filter({ hasText: text });\n    await todo.hover();\n    await todo.getByLabel('Delete').click();\n  }\n\n  async removeAll() {\n    while ((await this.todoItems.count()) > 0) {\n      await this.todoItems.first().hover();\n      await this.todoItems.getByLabel('Delete').first().click();\n    }\n  }\n}\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="todo-page.js"',title:'"todo-page.js"'}),"export class TodoPage {\n  /**\n   * @param {import('@playwright/test').Page} page\n   */\n  constructor(page) {\n    this.page = page;\n    this.inputBox = this.page.locator('input.new-todo');\n    this.todoItems = this.page.getByTestId('todo-item');\n  }\n\n  async goto() {\n    await this.page.goto('https://demo.playwright.dev/todomvc/');\n  }\n\n  /**\n   * @param {string} text\n   */\n  async addToDo(text) {\n    await this.inputBox.fill(text);\n    await this.inputBox.press('Enter');\n  }\n\n  /**\n   * @param {string} text\n   */\n  async remove(text) {\n    const todo = this.todoItems.filter({ hasText: text });\n    await todo.hover();\n    await todo.getByLabel('Delete').click();\n  }\n\n  async removeAll() {\n    while ((await this.todoItems.count()) > 0) {\n      await this.todoItems.first().hover();\n      await this.todoItems.getByLabel('Delete').first().click();\n    }\n  }\n}\n")))))),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="my-test.ts"',title:'"my-test.ts"'}),"import { test as base } from '@playwright/test';\nimport { TodoPage } from './todo-page';\n\n// Declare your options to type-check your configuration.\nexport type MyOptions = {\n  defaultItem: string;\n};\ntype MyFixtures = {\n  todoPage: TodoPage;\n};\n\n// Specify both option and fixture types.\nexport const test = base.extend<MyOptions & MyFixtures>({\n  // Define an option and provide a default value.\n  // We can later override it in the config.\n  defaultItem: ['Something nice', { option: true }],\n\n  // Our \"todoPage\" fixture depends on the option.\n  todoPage: async ({ page, defaultItem }, use) => {\n    const todoPage = new TodoPage(page);\n    await todoPage.goto();\n    await todoPage.addToDo(defaultItem);\n    await use(todoPage);\n    await todoPage.removeAll();\n  },\n});\nexport { expect } from '@playwright/test';\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="my-test.js"',title:'"my-test.js"'}),"const base = require('@playwright/test');\nconst { TodoPage } = require('./todo-page');\n\nexports.test = base.test.extend({\n  // Define an option and provide a default value.\n  // We can later override it in the config.\n  defaultItem: ['Something nice', { option: true }],\n\n  // Our \"todoPage\" fixture depends on the option.\n  todoPage: async ({ page, defaultItem }, use) => {\n    const todoPage = new TodoPage(page);\n    await todoPage.goto();\n    await todoPage.addToDo(defaultItem);\n    await use(todoPage);\n    await todoPage.removeAll();\n  },\n});\nexports.expect = base.expect;\n")))),(0,n.kt)("p",null,"We can now use ",(0,n.kt)("inlineCode",{parentName:"p"},"todoPage")," fixture as usual, and set the ",(0,n.kt)("inlineCode",{parentName:"p"},"defaultItem")," option in the config file."),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="playwright.config.ts"',title:'"playwright.config.ts"'}),"import { defineConfig } from '@playwright/test';\nimport type { MyOptions } from './my-test';\n\nexport default defineConfig<MyOptions>({\n  projects: [\n    {\n      name: 'shopping',\n      use: { defaultItem: 'Buy milk' },\n    },\n    {\n      name: 'wellbeing',\n      use: { defaultItem: 'Exercise!' },\n    },\n  ]\n});\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js",metastring:'title="playwright.config.ts"',title:'"playwright.config.ts"'}),"// @ts-check\n\nconst { defineConfig } = require('@playwright/test');\nmodule.exports = defineConfig({\n  projects: [\n    {\n      name: 'shopping',\n      use: { defaultItem: 'Buy milk' },\n    },\n    {\n      name: 'wellbeing',\n      use: { defaultItem: 'Exercise!' },\n    },\n  ]\n});\n")))),(0,n.kt)("h2",g({},{id:"execution-order"}),"Execution order"),(0,n.kt)("p",null,"Each fixture has a setup and teardown phase separated by the ",(0,n.kt)("inlineCode",{parentName:"p"},"await use()")," call in the fixture. Setup is executed before the fixture is used by the test/hook, and teardown is executed when the fixture will not be used by the test/hook anymore."),(0,n.kt)("p",null,"Fixtures follow these rules to determine the execution order:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"When fixture A depends on fixture B: B is always set up before A and teared down after A."),(0,n.kt)("li",{parentName:"ul"},"Non-automatic fixtures are executed lazily, only when the test/hook needs them."),(0,n.kt)("li",{parentName:"ul"},"Test-scoped fixtures are teared down after each test, while worker-scoped fixtures are only teared down when the worker process executing tests is shutdown.")),(0,n.kt)("p",null,"Consider the following example:"),(0,n.kt)(o.Z,{groupId:"js-flavor",defaultValue:"ts",values:[{label:"TypeScript",value:"ts"},{label:"JavaScript",value:"js"}],mdxType:"Tabs"},(0,n.kt)(r.Z,{value:"ts",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"import { test as base } from '@playwright/test';\n\nconst test = base.extend<{\n  testFixture: string,\n  autoTestFixture: string,\n  unusedFixture: string,\n}, {\n  workerFixture: string,\n  autoWorkerFixture: string,\n}>({\n  workerFixture: [async ({ browser }) => {\n    // workerFixture setup...\n    await use('workerFixture');\n    // workerFixture teardown...\n  }, { scope: 'worker' }],\n\n  autoWorkerFixture: [async ({ browser }) => {\n    // autoWorkerFixture setup...\n    await use('autoWorkerFixture');\n    // autoWorkerFixture teardown...\n  }, { scope: 'worker', auto: true }],\n\n  testFixture: [async ({ page, workerFixture }) => {\n    // testFixture setup...\n    await use('testFixture');\n    // testFixture teardown...\n  }, { scope: 'test' }],\n\n  autoTestFixture: [async () => {\n    // autoTestFixture setup...\n    await use('autoTestFixture');\n    // autoTestFixture teardown...\n  }, { scope: 'test', auto: true }],\n\n  unusedFixture: [async ({ page }) => {\n    // unusedFixture setup...\n    await use('unusedFixture');\n    // unusedFixture teardown...\n  }, { scope: 'test' }],\n});\n\ntest.beforeAll(async () => { /* ... */ });\ntest.beforeEach(async ({ page }) => { /* ... */ });\ntest('first test', async ({ page }) => { /* ... */ });\ntest('second test', async ({ testFixture }) => { /* ... */ });\ntest.afterEach(async () => { /* ... */ });\ntest.afterAll(async () => { /* ... */ });\n"))),(0,n.kt)(r.Z,{value:"js",mdxType:"TabItem"},(0,n.kt)("pre",null,(0,n.kt)("code",g({parentName:"pre"},{className:"language-js"}),"const { test: base } = require('@playwright/test');\n\nconst test = base.extend({\n  workerFixture: [async ({ browser }) => {\n    // workerFixture setup...\n    await use('workerFixture');\n    // workerFixture teardown...\n  }, { scope: 'worker' }],\n\n  autoWorkerFixture: [async ({ browser }) => {\n    // autoWorkerFixture setup...\n    await use('autoWorkerFixture');\n    // autoWorkerFixture teardown...\n  }, { scope: 'worker', auto: true }],\n\n  testFixture: [async ({ page, workerFixture }) => {\n    // testFixture setup...\n    await use('testFixture');\n    // testFixture teardown...\n  }, { scope: 'test' }],\n\n  autoTestFixture: [async () => {\n    // autoTestFixture setup...\n    await use('autoTestFixture');\n    // autoTestFixture teardown...\n  }, { scope: 'test', auto: true }],\n\n  unusedFixture: [async ({ page }) => {\n    // unusedFixture setup...\n    await use('unusedFixture');\n    // unusedFixture teardown...\n  }, { scope: 'test' }],\n});\n\ntest.beforeAll(async () => { /* ... */ });\ntest.beforeEach(async ({ page }) => { /* ... */ });\ntest('first test', async ({ page }) => { /* ... */ });\ntest('second test', async ({ testFixture }) => { /* ... */ });\ntest.afterEach(async () => { /* ... */ });\ntest.afterAll(async () => { /* ... */ });\n")))),(0,n.kt)("p",null,"Normally, if all tests pass and no errors are thrown, the order of execution is as following."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"worker setup and ",(0,n.kt)("inlineCode",{parentName:"li"},"beforeAll")," section:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"browser")," setup because it is required by ",(0,n.kt)("inlineCode",{parentName:"li"},"autoWorkerFixture"),"."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"autoWorkerFixture")," setup because automatic worker fixtures are always set up before anything else."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"beforeAll")," runs."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"first test")," section:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"autoTestFixture")," setup because automatic test fixtures are always set up before test and ",(0,n.kt)("inlineCode",{parentName:"li"},"beforeEach")," hooks."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"page")," setup because it is required in ",(0,n.kt)("inlineCode",{parentName:"li"},"beforeEach")," hook."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"beforeEach")," runs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"first test")," runs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"afterEach")," runs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"page")," teardown because it is a test-scoped fixture and should be teared down after the test finishes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"autoTestFixture")," teardown because it is a test-scoped fixture and should be teared down after the test finishes."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"second test")," section:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"autoTestFixture")," setup because automatic test fixtures are always set up before test and ",(0,n.kt)("inlineCode",{parentName:"li"},"beforeEach")," hooks."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"page")," setup because it is required in ",(0,n.kt)("inlineCode",{parentName:"li"},"beforeEach")," hook."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"beforeEach")," runs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"workerFixture")," setup because it is required by ",(0,n.kt)("inlineCode",{parentName:"li"},"testFixture")," that is required by the ",(0,n.kt)("inlineCode",{parentName:"li"},"second test"),"."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"testFixture")," setup because it is required by the ",(0,n.kt)("inlineCode",{parentName:"li"},"second test"),"."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"second test")," runs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"afterEach")," runs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"testFixture")," teardown because it is a test-scoped fixture and should be teared down after the test finishes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"page")," teardown because it is a test-scoped fixture and should be teared down after the test finishes."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"autoTestFixture")," teardown because it is a test-scoped fixture and should be teared down after the test finishes."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"afterAll")," and worker teardown section:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"afterAll")," runs."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"workerFixture")," teardown because it is a workers-scoped fixture and should be teared down once at the end."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"autoWorkerFixture")," teardown because it is a workers-scoped fixture and should be teared down once at the end."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"browser")," teardown because it is a workers-scoped fixture and should be teared down once at the end.")))),(0,n.kt)("p",null,"A few observations:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"page")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"autoTestFixture")," are set up and teared down for each test, as test-scoped fixtures."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"unusedFixture")," is never set up because it is not used by any tests/hooks."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"testFixture")," depends on ",(0,n.kt)("inlineCode",{parentName:"li"},"workerFixture")," and triggers its setup."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"workerFixture")," is lazily set up before the second test, but teared down once during worker shutdown, as a worker-scoped fixture."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"autoWorkerFixture")," is set up for ",(0,n.kt)("inlineCode",{parentName:"li"},"beforeAll")," hook, but ",(0,n.kt)("inlineCode",{parentName:"li"},"autoTestFixture")," is not.")))}x.isMDXComponent=!0}}]);